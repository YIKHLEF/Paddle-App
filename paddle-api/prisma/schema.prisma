// Sch√©ma Prisma pour l'application Paddle
// Database: PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== USERS ====================

model User {
  id                String    @id @default(uuid())
  email             String    @unique
  phoneNumber       String?   @unique
  passwordHash      String?

  // Profile
  firstName         String
  lastName          String
  username          String    @unique
  bio               String?   @db.VarChar(200)
  avatarUrl         String?
  dateOfBirth       DateTime
  gender            Gender

  // Paddle specific
  skillLevel        SkillLevel
  preferredPosition Position
  dominantHand      DominantHand
  location          String
  latitude          Float?
  longitude         Float?

  // Subscription
  subscriptionTier  SubscriptionTier @default(FREE)
  subscriptionId    String?
  subscriptionStart DateTime?
  subscriptionEnd   DateTime?
  trialUsed         Boolean          @default(false)

  // Social auth
  googleId          String?   @unique
  appleId           String?   @unique
  facebookId        String?   @unique

  // Metadata
  isVerified        Boolean   @default(false)
  isActive          Boolean   @default(true)
  lastActiveAt      DateTime  @default(now())
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  organizedMatches  Match[]   @relation("MatchOrganizer")
  participations    MatchParticipant[]
  sentMessages      Message[] @relation("MessageSender")
  receivedMessages  Message[] @relation("MessageReceiver")
  bookings          Booking[]
  reviews           Review[]  @relation("ReviewAuthor")
  receivedReviews   Review[]  @relation("ReviewTarget")
  statistics        UserStatistics?
  notifications     Notification[]
  payments          Payment[]
  clubs             ClubMembership[]

  @@index([location])
  @@index([skillLevel])
  @@index([email])
  @@map("users")
}

model UserStatistics {
  id                String   @id @default(uuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  totalMatches      Int      @default(0)
  matchesWon        Int      @default(0)
  matchesLost       Int      @default(0)
  winRate           Float    @default(0)
  currentStreak     Int      @default(0)
  longestWinStreak  Int      @default(0)
  totalPlayTime     Int      @default(0) // minutes
  ranking           Int?
  eloScore          Int      @default(1000)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@map("user_statistics")
}

// ==================== MATCHES ====================

model Match {
  id                String    @id @default(uuid())

  // Match details
  type              MatchType
  format            MatchFormat
  status            MatchStatus @default(SCHEDULED)
  visibility        Visibility  @default(PUBLIC)

  organizerId       String
  organizer         User      @relation("MatchOrganizer", fields: [organizerId], references: [id])

  courtId           String?
  court             Court?    @relation(fields: [courtId], references: [id])

  // Timing
  scheduledAt       DateTime
  startedAt         DateTime?
  endedAt           DateTime?
  duration          Int?      // minutes

  // Requirements
  requiredLevel     SkillLevel?
  maxParticipants   Int       @default(4)

  // Metadata
  description       String?
  isRecurring       Boolean   @default(false)
  recurrenceRule    String?   // iCal RRULE format

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  participants      MatchParticipant[]
  scores            MatchScore[]
  chatMessages      ChatMessage[]

  @@index([scheduledAt])
  @@index([status])
  @@map("matches")
}

model MatchParticipant {
  id                String   @id @default(uuid())

  matchId           String
  match             Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  userId            String
  user              User     @relation(fields: [userId], references: [id])

  status            ParticipantStatus @default(PENDING)
  team              Int?     // 1 or 2 for team matches
  checkedInAt       DateTime?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([matchId, userId])
  @@map("match_participants")
}

model MatchScore {
  id                String   @id @default(uuid())

  matchId           String
  match             Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  team1Score        Int
  team2Score        Int
  setNumber         Int

  createdAt         DateTime @default(now())

  @@map("match_scores")
}

// ==================== COURTS & CLUBS ====================

model Club {
  id                String   @id @default(uuid())

  name              String
  description       String?
  address           String
  city              String
  postalCode        String
  country           String
  latitude          Float
  longitude         Float

  phoneNumber       String?
  email             String?
  website           String?

  // Features
  facilities        String[] // ["parking", "bar", "shop", "showers"]
  openingHours      Json     // {"monday": {"open": "08:00", "close": "22:00"}}

  // Media
  logoUrl           String?
  photos            String[]

  // Metadata
  isPartner         Boolean  @default(false)
  averageRating     Float?
  totalReviews      Int      @default(0)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  courts            Court[]
  memberships       ClubMembership[]

  @@index([city])
  @@index([latitude, longitude])
  @@map("clubs")
}

model Court {
  id                String   @id @default(uuid())

  clubId            String
  club              Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)

  name              String
  courtNumber       Int
  type              CourtType // INDOOR, OUTDOOR
  surface           String    // "grass", "cement", "artificial turf"

  // Availability
  isActive          Boolean  @default(true)

  // Pricing
  pricePerHour      Float
  currency          String   @default("EUR")

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  bookings          Booking[]
  matches           Match[]

  @@map("courts")
}

model ClubMembership {
  id                String   @id @default(uuid())

  userId            String
  user              User     @relation(fields: [userId], references: [id])

  clubId            String
  club              Club     @relation(fields: [clubId], references: [id])

  membershipType    String   // "member", "premium", etc.
  startDate         DateTime
  endDate           DateTime?

  createdAt         DateTime @default(now())

  @@unique([userId, clubId])
  @@map("club_memberships")
}

// ==================== BOOKINGS ====================

model Booking {
  id                String   @id @default(uuid())

  userId            String
  user              User     @relation(fields: [userId], references: [id])

  courtId           String
  court             Court    @relation(fields: [courtId], references: [id])

  // Timing
  startTime         DateTime
  endTime           DateTime
  duration          Int      // minutes

  // Status & Payment
  status            BookingStatus @default(PENDING)
  totalPrice        Float
  currency          String   @default("EUR")
  paymentMethod     PaymentMethod?
  paidAt            DateTime?

  // Metadata
  notes             String?
  cancellationReason String?
  cancelledAt       DateTime?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([startTime])
  @@index([status])
  @@map("bookings")
}

// ==================== MESSAGING ====================

model Conversation {
  id                String   @id @default(uuid())

  type              ConversationType @default(DIRECT)
  name              String?
  avatarUrl         String?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  messages          Message[]
  participants      ConversationParticipant[]

  @@map("conversations")
}

model ConversationParticipant {
  id                String   @id @default(uuid())

  conversationId    String
  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  userId            String

  lastReadAt        DateTime?
  mutedUntil        DateTime?

  createdAt         DateTime @default(now())

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Message {
  id                String   @id @default(uuid())

  conversationId    String
  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId          String
  sender            User     @relation("MessageSender", fields: [senderId], references: [id])

  recipientId       String?
  recipient         User?    @relation("MessageReceiver", fields: [recipientId], references: [id])

  type              MessageType @default(TEXT)
  content           String
  attachmentUrl     String?

  isRead            Boolean  @default(false)
  readAt            DateTime?

  createdAt         DateTime @default(now())

  @@index([conversationId])
  @@map("messages")
}

model ChatMessage {
  id                String   @id @default(uuid())

  matchId           String
  match             Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  userId            String
  content           String

  createdAt         DateTime @default(now())

  @@map("chat_messages")
}

// ==================== REVIEWS & RATINGS ====================

model Review {
  id                String   @id @default(uuid())

  authorId          String
  author            User     @relation("ReviewAuthor", fields: [authorId], references: [id])

  targetId          String
  target            User     @relation("ReviewTarget", fields: [targetId], references: [id])

  // Ratings (1-5)
  punctualityRating Int
  fairPlayRating    Int
  skillRating       Int
  friendlinessRating Int
  overallRating     Float

  comment           String?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([authorId, targetId])
  @@map("reviews")
}

// ==================== SUBSCRIPTIONS & PAYMENTS ====================

model Payment {
  id                String   @id @default(uuid())

  userId            String
  user              User     @relation(fields: [userId], references: [id])

  amount            Float
  currency          String   @default("EUR")
  status            PaymentStatus

  type              String   // "subscription", "booking", "tournament"
  provider          String   // "stripe", "apple", "google"
  providerPaymentId String?

  metadata          Json?

  createdAt         DateTime @default(now())

  @@index([userId])
  @@map("payments")
}

// ==================== NOTIFICATIONS ====================

model Notification {
  id                String   @id @default(uuid())

  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  type              NotificationType
  title             String
  body              String
  data              Json?

  isRead            Boolean  @default(false)
  readAt            DateTime?

  createdAt         DateTime @default(now())

  @@index([userId, isRead])
  @@map("notifications")
}

model DeviceToken {
  id                String   @id @default(uuid())

  userId            String
  token             String   @unique
  platform          Platform

  lastUsedAt        DateTime @default(now())
  createdAt         DateTime @default(now())

  @@index([userId])
  @@map("device_tokens")
}

// ==================== ENUMS ====================

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
  PRO
}

enum Position {
  LEFT
  RIGHT
  BOTH
}

enum DominantHand {
  RIGHT
  LEFT
}

enum SubscriptionTier {
  FREE
  STANDARD
  PREMIUM
}

enum MatchType {
  FRIENDLY
  RANKED
  TRAINING
  TOURNAMENT
  DISCOVERY
}

enum MatchFormat {
  SINGLES
  DOUBLES
}

enum MatchStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Visibility {
  PUBLIC
  PRIVATE
  FRIENDS_ONLY
}

enum ParticipantStatus {
  PENDING
  ACCEPTED
  DECLINED
  CHECKED_IN
}

enum CourtType {
  INDOOR
  OUTDOOR
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum PaymentMethod {
  CARD
  CASH
  ON_SITE
  SUBSCRIPTION
}

enum ConversationType {
  DIRECT
  GROUP
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  LOCATION
  MATCH_INVITATION
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum NotificationType {
  MATCH_INVITATION
  MATCH_REMINDER
  BOOKING_CONFIRMATION
  MESSAGE
  REVIEW_REQUEST
  SUBSCRIPTION_RENEWAL
  ACHIEVEMENT
  GENERAL
}

enum Platform {
  ios
  android
}
